"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHandleBidiStreamingCall = exports.toHandleClientStreamingCall = exports.toHandleServerStreamingCall = exports.toHandleUnaryCall = exports.CANCEL_EVENT = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
exports.CANCEL_EVENT = 'cancelled';
const toHandleUnaryCall = (fn) => {
    const f = async (call, callback) => {
        (0, rxjs_1.from)(fn(call.request, call.metadata, call)).subscribe((data) => callback(null, data), (err) => callback(err));
    };
    return f;
};
exports.toHandleUnaryCall = toHandleUnaryCall;
const toHandleServerStreamingCall = (fn) => {
    const f = async (call) => {
        const result$ = await fn(call.request, call.metadata, call);
        await result$
            .pipe((0, operators_1.takeUntil)((0, rxjs_1.fromEvent)(call, exports.CANCEL_EVENT)), (0, operators_1.catchError)((err) => {
            call.emit('error', err);
            return rxjs_1.EMPTY;
        }))
            .forEach((data) => call.write(data));
        call.end();
    };
    return f;
};
exports.toHandleServerStreamingCall = toHandleServerStreamingCall;
const toHandleClientStreamingCall = (fn) => {
    const f = async (call, callback) => {
        const req = new rxjs_1.Subject();
        call.on('data', (m) => req.next(m));
        call.on('error', (e) => {
            const isCancelledError = String(e).toLowerCase().indexOf('cancelled');
            if (isCancelledError) {
                call.end();
                return;
            }
            req.error(e);
        });
        call.on('end', () => req.complete());
        (0, rxjs_1.from)(fn(req.asObservable(), call.metadata, call)).subscribe((data) => callback(null, data), (err) => callback(err));
    };
    return f;
};
exports.toHandleClientStreamingCall = toHandleClientStreamingCall;
const toHandleBidiStreamingCall = (fn) => {
    const f = async (call) => {
        const req = new rxjs_1.Subject();
        call.on('data', (m) => req.next(m));
        call.on('error', (e) => {
            const isCancelledError = String(e).toLowerCase().indexOf('cancelled');
            if (isCancelledError) {
                call.end();
                return;
            }
            req.error(e);
        });
        call.on('end', () => req.complete());
        const result$ = await fn(req.asObservable(), call.metadata, call);
        await result$
            .pipe((0, operators_1.takeUntil)((0, rxjs_1.fromEvent)(call, exports.CANCEL_EVENT)), (0, operators_1.catchError)((err) => {
            call.emit('error', err);
            return rxjs_1.EMPTY;
        }))
            .forEach((data) => call.write(data));
        call.end();
    };
    return f;
};
exports.toHandleBidiStreamingCall = toHandleBidiStreamingCall;
//# sourceMappingURL=server.js.map