"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promisifyUnaryCall = exports.promisifyClientStream = exports.observerToWriteStream = exports.readStreamToObserver = exports.GRPC_CANCELLED = void 0;
const rxjs_1 = require("rxjs");
exports.GRPC_CANCELLED = 'Cancelled';
const readStreamToObserver = (call) => {
    const stream = new rxjs_1.Observable((observer) => {
        let isClientCanceled = false;
        call.on('data', (data) => observer.next(data));
        call.on('error', (error) => {
            if (error.details === exports.GRPC_CANCELLED) {
                call.destroy();
                if (isClientCanceled) {
                    return;
                }
            }
            observer.error(error);
        });
        call.on('end', () => {
            call.removeAllListeners();
            observer.complete();
        });
        return () => {
            if (call.finished) {
                return;
            }
            isClientCanceled = true;
            call.cancel();
        };
    });
    return stream;
};
exports.readStreamToObserver = readStreamToObserver;
const observerToWriteStream = (o, call) => {
    const sub = o.subscribe((val) => call.write(val), (err) => call.emit('error', err), () => call.end());
    call.on('end', () => {
        sub.unsubscribe();
        call.removeAllListeners();
    });
};
exports.observerToWriteStream = observerToWriteStream;
function promisifyClientStream(clientStream, c, ...args) {
    let call;
    const p = new Promise((resolve, reject) => {
        call = clientStream.call(c, ...args, (err, resp) => {
            if (err) {
                return reject(err);
            }
            return resolve(resp);
        });
    });
    return [call, p];
}
exports.promisifyClientStream = promisifyClientStream;
function promisifyUnaryCall(unaryCall, c) {
    return ((...args) => new Promise((resolve, reject) => {
        const res = {};
        const call = unaryCall.call(c, ...args, (err, resp) => {
            if (err) {
                return reject(err);
            }
            res.res = resp;
            resolve(res);
        });
        call.on('metadata', (md) => {
            res.metadata = md;
        });
        call.on('status', (status) => {
            res.status = status;
        });
    }));
}
exports.promisifyUnaryCall = promisifyUnaryCall;
//# sourceMappingURL=client.js.map