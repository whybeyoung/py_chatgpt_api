import * as grpc from '@grpc/grpc-js';
import { Observable } from 'rxjs';
export declare const GRPC_CANCELLED = "Cancelled";
export declare type ClientReadableStreamRes<T extends grpc.ClientReadableStream<any> | grpc.ClientDuplexStream<any, any>> = T extends grpc.ClientDuplexStream<any, infer Res> ? Res : T extends grpc.ClientReadableStream<infer Res> ? Res : never;
export declare const readStreamToObserver: <T extends grpc.ClientReadableStream<any> | grpc.ClientDuplexStream<any, any>>(call: T) => Observable<ClientReadableStreamRes<T>>;
export declare const observerToWriteStream: <T = any>(o: Observable<T>, call: grpc.ClientWritableStream<T>) => void;
export declare function promisifyClientStream<T extends (...args: any[]) => grpc.ClientWritableStream<any>>(clientStream: T, c: grpc.Client, ...args: GetOverloadArgs<PromisifyUnary<GetOverloadArgs<T>>>): [ReturnType<T>, GetOverloadReturnType<UnionToIntersection<PromisifyWithoutResponseWrapper<GetOverloadArgs<T>>>>];
export interface Response<Res> {
    res: Res;
    status: grpc.StatusObject;
    metadata: grpc.Metadata;
}
export declare function promisifyUnaryCall<T extends (...args: any[]) => grpc.ClientUnaryCall>(unaryCall: T, c: grpc.Client): PromisifyUnaryCall<T>;
export declare type Callback<T> = (err: Error | null, reply: T) => void;
export declare type PromisifyUnary<T extends any[]> = T extends [Callback<infer U>?] ? () => Promise<Response<U>> : T extends [infer T1, Callback<infer P>?] ? (arg1: T1) => Promise<Response<P>> : T extends [infer T1, infer T2, Callback<infer U>?] ? (arg1: T1, arg2: T2) => Promise<Response<U>> : T extends [infer T1, infer T2, infer T3, Callback<infer U>?] ? (arg1: T1, arg2: T2, arg3: T3) => Promise<Response<U>> : T extends [infer T1, infer T2, infer T3, infer T4, Callback<infer U>?] ? (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<Response<U>> : T;
export declare type GetOverloadArgs<T> = T extends {
    (...o: infer U): void;
    (...o: infer U2): void;
    (...o: infer U3): void;
} ? U | U2 | U3 : T extends {
    (...o: infer U): void;
    (...o: infer U2): void;
} ? U | U2 : T extends {
    (...o: infer U): void;
} ? U : never;
export declare type GetOverloadReturnType<T> = T extends {
    (...o: any[]): infer U;
    (...o: any[]): infer U2;
    (...o: any[]): infer U3;
} ? U | U2 | U3 : T extends {
    (...o: infer U): void;
    (...o: infer U2): void;
} ? U | U2 : T extends {
    (...o: infer U): void;
} ? U : never;
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare type PromisifyUnaryCall<T> = UnionToIntersection<PromisifyUnary<GetOverloadArgs<T>>>;
export declare type PromisifyWithoutResponseWrapper<T extends any[]> = T extends [
    Callback<infer U>?
] ? () => Promise<U> : T extends [infer T1, Callback<infer P>?] ? (arg1: T1) => Promise<P> : T extends [infer T1, infer T2, Callback<infer U>?] ? (arg1: T1, arg2: T2) => Promise<U> : T extends [infer T1, infer T2, infer T3, Callback<infer U>?] ? (arg1: T1, arg2: T2, arg3: T3) => Promise<U> : T extends [infer T1, infer T2, infer T3, infer T4, Callback<infer U>?] ? (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<U> : T;
export declare type PromisifyClientStream<T> = UnionToIntersection<PromisifyWithoutResponseWrapper<GetOverloadArgs<T>>>;
export {};
